<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>bss - Bundle Streaming Service library</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:mingw-dvlpr@lists.sourceforge.net" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->
<!--

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>
-->
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>bss - Bundle Streaming Service library</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    #include &quot;bss.h&quot;</pre>
<pre>
    typedef int (*RTBHandler)(time_t time, unsigned long count, char *buffer, int bufLength);</pre>
<pre>
    [see description for available functions]</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>The BSS library supports the streaming of data over delay-tolerant
networking (DTN) bundles.  The intent of the library is to enable applications
that pass streaming data received in transmission time order (i.e., without
time regressions) to an application-specific ``display'' function -- notionally
for immediate real-time display -- but to store <strong>all</strong> received data (including
out-of-order data) in a private database for playback under user control.  The
reception and real-time display of in-order data is performed by a background
thread, leaving the application's main (foreground) thread free to respond to
user commands controlling playback or other application-specific functions.</p>
<p>The application-specific ``display'' function invoked by the background thread
must conform to the RTBHandler type definition.  It must return 0 on success,
-1 on any error that should terminate the background thread.  Only on return
from this function will the background thread proceed to acquire the next BSS
payload.</p>
<p>All data acquired by the BSS background thread is written to a BSS database
comprising three files: table, list, and data.  The name of the database
is the root name that is common to the three files, e.g., <em>db3</em>.tbl,
<em>db3</em>.lst, <em>db3</em>.dat would be the three files making up the <em>db3</em> BSS
database.  All three files of the selected BSS database must reside in the
same directory of the file system.</p>
<p>Several replay navigation functions in the BSS library require that the
application provide a navigation state structure of type bssNav as defined
in the bss.h header file.  The application is not reponsible for populating
this structure; it's strictly for the private use of the BSS library.</p>
<dl>
<dt><strong><a name="item_bssopen">int bssOpen(char *bssName, char *path, char *eid)</a></strong>

<dd>
<p>Opens access to a BSS database, to enable data playback.  <em>bssName</em>
identifies the specific BSS database that is to be opened.  <em>path</em> identifies
the directory in which the database resides.  <em>eid</em> is ignored.  On any
failure, returns -1.  On success, returns zero.</p>
</dd>
</li>
<dt><strong><a name="item_bssstart">int bssStart(char *bssName, char *path, char *eid, char *buffer, int bufLen, RTBHandler handler)</a></strong>

<dd>
<p>Starts a BSS data acquisition background thread.  <em>bssName</em> identifies the
BSS database into which data will be acquired.  <em>path</em> identifies the
directory in which that database resides.  <em>eid</em> is used to open the BP
endpoint at which the delivered BSS bundle payload contents will be
acquired.  <em>buffer</em> identifies a data acquisition buffer, which must be
provided by the application, and <em>bufLen</em> indicates the length of that
buffer; received bundle payloads in excess of this length will be discarded.</p>
</dd>
<dd>
<p><em>handler</em> identifies the display function to which each in-order bundle
payload will be passed.  The <em>time</em> and <em>count</em> parameters passed to this
function identify the received bundle, indicating the bundle's creation
timestamp time (in seconds) and counter value.  The <em>buffer</em> and <em>bufLength</em>
parameters indicate the location into which the bundle's payload was
acquired and the length of the acquired payload.  <em>handler</em> must return -1 on
any unrecoverable system error, 0 otherwise.  A return value of -1 from
<em>handler</em> will terminate the BSS data acquisition background thread.</p>
</dd>
<dd>
<p>On any failure, returns -1.  On success, returns zero.</p>
</dd>
</li>
<dt><strong><a name="item_bssrun">int bssRun(char *bssName, char *path, char *eid, char *buffer, int bufLen, RTBHandler handler)</a></strong>

<dd>
<p>A convenience function that performs both <a href="#item_bssopen"><code>bssOpen()</code></a> and bssStart().  On any
failure, returns -1.  On success, returns zero.</p>
</dd>
</li>
<dt><strong><a name="item_bssclose">void <code>bssClose()</code></a></strong>

<dd>
<p>Terminates data playback access to the most recently opened BSS database.</p>
</dd>
</li>
<dt><strong><a name="item_bssstop">void <code>bssStop()</code></a></strong>

<dd>
<p>Terminates the most recently initiated BSS data acquisition background thread.</p>
</dd>
</li>
<dt><strong><a name="item_bssexit">void <code>bssExit()</code></a></strong>

<dd>
<p>A convenience function that performs both <a href="#item_bssclose"><code>bssClose()</code></a> and bssStop().</p>
</dd>
</li>
<dt><strong><a name="item_bssread">long bssRead(bssNav nav, char *data, int dataLen)</a></strong>

<dd>
<p>Copies the data at the current playback position in the database, as indicated
by <em>nav</em>, into <em>data</em>; if the length of the data is in excess of <em>dataLen</em>
then an error condition is asserted (i.e., -1 is returned).  Note that <a href="#item_bssread"><code>bssRead()</code></a>
cannot be successfully called until <em>nav</em> has been populated, nominally by
a preceding call to bssSeek(), bssNext(), or bssPrev().  Returns the length
of data read, or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_bssseek">long bssSeek(bssNav *nav, time_t time, time_t *curTime, unsigned long *count)</a></strong>

<dd>
<p>Sets the current playback position in the database, in <em>nav</em>, to the data
received in the bundle with the earliest creation time that was greater than
or equal to <em>time</em>.  Populates <em>nav</em> and also returns the creation time and
bundle ID count of that bundle in <em>curTime</em> and <em>count</em>.  Returns the length
of data at this location, or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_bssseek_read">long bssSeek_read(bssNav *nav, time_t time, time_t *curTime, unsigned long *count, char *data, int dataLen)</a></strong>

<dd>
<p>A convenience function that performs <a href="#item_bssseek"><code>bssSeek()</code></a> followed by an immediate
<a href="#item_bssread"><code>bssRead()</code></a> to return the data at the new playback position.  Returns the length
of data read, or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_bssnext">long bssNext(bssNav *nav, time_t *curTime, unsigned long *count)</a></strong>

<dd>
<p>Sets the playback position in the database, in <em>nav</em>, to the data received
in the bundle with the earliest creation time and ID count greater than that
of the bundle at the current playback position.  Populates <em>nav</em> and also
returns the creation time and bundle ID count of that bundle in <em>curTime</em>
and <em>count</em>.  Returns the length of data at this location (if any),
-2 on reaching end of list, or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_bssnext_read">long bssNext_read(bssNav *nav, time_t *curTime, unsigned long *count, char *data, int dataLen)</a></strong>

<dd>
<p>A convenience function that performs <a href="#item_bssnext"><code>bssNext()</code></a> followed by an immediate
<a href="#item_bssread"><code>bssRead()</code></a> to return the data at the new playback position.  Returns the
length of data read, -2 on reaching end of list, or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_bssprev">long bssPrev(bssNav *nav, time_t *curTime, unsigned long *count)</a></strong>

<dd>
<p>Sets the playback position in the database, in <em>nav</em>, to the data received
in the bundle with the latest creation time and ID count earlier than that
of the bundle at the current playback position.  Populates <em>nav</em> and also
returns the creation time and bundle ID count of that bundle in <em>curTime</em>
and <em>count</em>.  Returns the length of data at this location (if any), -2 on
reaching end of list, or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_bssprev_read">long bssPrev_read(bssNav *nav, time_t *curTime, unsigned long *count, char *data, int dataLen)</a></strong>

<dd>
<p>A convenience function that performs <a href="#item_bssprev"><code>bssPrev()</code></a> followed by an immediate
<a href="#item_bssread"><code>bssRead()</code></a> to return the data at the new playback position.  Returns the
length of data read, -2 on reaching end of list, or -1 on any error.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><code>bp(3)</code></p>

</body>

</html>
