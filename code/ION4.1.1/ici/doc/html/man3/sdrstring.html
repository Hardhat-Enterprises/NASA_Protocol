<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>sdrstring - Simple Data Recorder string functions</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:mingw-dvlpr@lists.sourceforge.net" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->
<!--

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>
-->
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>sdrstring - Simple Data Recorder string functions</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    #include &quot;sdr.h&quot;</pre>
<pre>
    Object sdr_string_create (Sdr sdr, char *from);
    Object sdr_string_dup    (Sdr sdr, Object from);
    int    sdr_string_length (Sdr sdr, Object string);
    int    sdr_string_read   (Sdr sdr, char *into, Object string);</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>SDR strings are used to record strings of up to 255 ASCII characters
in the heap space of an SDR.  Unlike standard C strings, which are terminated
by a zero byte, SDR strings record the length of the string as
part of the string object.</p>
<p>To store strings longer than 255 characters, use <code>sdr_malloc()</code> and <code>sdr_write()</code>
instead of these functions.</p>
<dl>
<dt><strong><a name="item_sdr_string_create">Object sdr_string_create(Sdr sdr, char *from)</a></strong>

<dd>
<p>Creates a ``self-delimited string'' in the heap of the
indicated SDR, allocating the required space and copying the
indicated content.  <em>from</em> must be a standard C
string for which <code>strlen()</code> must not exceed 255; if
it does, or if insufficient SDR space is available, 0
is returned.  Otherwise the address of the newly created SDR
string object is returned.  To destroy, just use sdr_free().</p>
</dd>
</li>
<dt><strong><a name="item_sdr_string_dup">Object sdr_string_dup(Sdr sdr, Object from)</a></strong>

<dd>
<p>Creates a duplicate of the SDR string whose address is
<em>from</em>, allocating the required space and copying the
original string's content.  If insufficient SDR space is
available, 0 is returned.  Otherwise the address of the newly
created copy of the original SDR string object is returned.  To
destroy, use sdr_free().</p>
</dd>
</li>
<dt><strong><a name="item_sdr_string_length">int sdr_string_length(Sdr sdr, Object string)</a></strong>

<dd>
<p>Returns the length of the indicated self-delimited string (as would
be returned by strlen()), or -1 on any error.</p>
</dd>
</li>
<dt><strong><a name="item_sdr_string_read">int sdr_string_read(Sdr sdr, char *into, Object string)</a></strong>

<dd>
<p>Retrieves the content of the indicated self-delimited string into
memory as a standard C string (NULL terminated).  Length of <em>into</em>
should normally be SDRSTRING_BUFSZ (i.e., 256) to allow for the largest
possible SDR string (255 characters) plus the terminating NULL.  Returns
length of string (as would be returned by strlen()), or -1 on any error.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>sdr(3), sdrlist(3), sdrtable(3), <code>string(3)</code></p>

</body>

</html>
